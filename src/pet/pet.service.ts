// src/pet/pet.service.ts
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindManyOptions } from 'typeorm';
import { Pet } from './pet.entity';
import { User } from 'src/user/user.entity'; // Assuming User entity is in src/user
import * as fs from 'fs';
import * as path from 'path';
import { CreatePetDto } from 'src/auth/dto/create-pet.dto';
import { UpdatePetDto } from 'src/auth/dto/update-pet.dto';
import { QueryPetDto } from 'src/auth/dto/query-pet.dto';

@Injectable()
export class PetService {
  constructor(
    @InjectRepository(Pet)
    private petRepository: Repository<Pet>,
  ) {}

  async create(
    createPetDto: CreatePetDto,
    user: User,
    photoFile?: Express.Multer.File,
  ): Promise<Pet> {
    const pet = this.petRepository.create({
      ...createPetDto,
      user: user, // Associate with the user entity
      userId: user.id, // Store userId explicitly
      photoUrl: photoFile?.filename, // Store only the filename generated by Multer
    });
    return this.petRepository.save(pet);
  }

  async findAll(userId: number, queryDto: QueryPetDto): Promise<Pet[]> {
    const queryOptions: FindManyOptions<Pet> = {
      where: { userId }, // Only get pets for the logged-in user
      order: { created_at: 'DESC' }, // Example ordering
    };

    // Apply filters if provided
    if (queryDto.type) {
        queryOptions.where = { ...queryOptions.where, type: queryDto.type };
    }
    if (queryDto.age !== undefined) { // Check for undefined as age can be 0
        queryOptions.where = { ...queryOptions.where, age: queryDto.age };
    }

    return this.petRepository.find(queryOptions);
  }

  async findOne(id: number, userId: number): Promise<Pet> {
    const pet = await this.petRepository.findOne({ where: { id } });

    if (!pet) {
      throw new NotFoundException(`Pet with ID ${id} not found`);
    }

    // Security check: Ensure the pet belongs to the requesting user
    if (pet.userId !== userId) {
      throw new ForbiddenException('You do not have permission to access this pet');
    }

    return pet;
  }

  async update(
    id: number,
    updatePetDto: UpdatePetDto,
    userId: number,
    photoFile?: Express.Multer.File,
  ): Promise<Pet> {
    const pet = await this.findOne(id, userId); // findOne already includes ownership check

    // Handle potential photo update
    let oldPhotoUrl: string | null = null;
    if (photoFile) {
        oldPhotoUrl = pet.photoUrl; // Store old filename for deletion
        pet.photoUrl = photoFile.filename; // Update with new filename
    }

    // Update other properties
    Object.assign(pet, updatePetDto);

    const updatedPet = await this.petRepository.save(pet);

    // Delete old photo file *after* successful save
    if (oldPhotoUrl) {
        const oldPhotoPath = path.join('./uploads/pets', oldPhotoUrl);
        fs.unlink(oldPhotoPath, (err) => {
            if (err) {
                console.error(`Failed to delete old photo: ${oldPhotoPath}`, err);
                // Log error, but don't fail the request as the pet is updated
            }
        });
    }

    return updatedPet;
  }

  async remove(id: number, userId: number): Promise<void> {
    const pet = await this.findOne(id, userId); // findOne includes ownership check

    const photoUrl = pet.photoUrl; // Get filename before deleting entity

    const result = await this.petRepository.delete(id);

    if (result.affected === 0) {
      throw new NotFoundException(`Pet with ID ${id} not found`);
    }

    // Delete the associated photo file
    if (photoUrl) {
      const photoPath = path.join('./uploads/pets', photoUrl);
      fs.unlink(photoPath, (err) => {
        if (err) {
            console.error(`Failed to delete photo: ${photoPath}`, err);
             // Log error, but don't fail the request as the pet record is deleted
        }
      });
    }
  }
}